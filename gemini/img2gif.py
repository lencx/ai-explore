import os
import datetime
import threading
import time
import subprocess
from dotenv import load_dotenv
from io import BytesIO
from PIL import Image
from google import genai
from google.genai import types

def init_session():
    """
    Initialize the session: load environment variables, create folders, and generate the Markdown file path.
    初始化会话：加载环境变量、创建文件夹、生成 Markdown 文件路径
    """
    # Load environment variables from .env file / 加载 .env 文件中的环境变量
    load_dotenv()

    # Retrieve GEMINI_API_KEY. Raise error if missing / 获取 GEMINI_API_KEY 环境变量，如果缺失则抛出错误
    api_key = os.environ.get("GEMINI_API_KEY")
    if not api_key:
        # Raise an error if the API key is missing / 若 API 密钥缺失则抛出错误
        raise ValueError("GEMINI_API_KEY is missing. Please set it in the .env file.")

    # Initialize client to call Google Generative AI / 初始化 client，用于调用 Google Generative AI
    client = genai.Client(api_key=api_key)

    # Generate a unique folder name for the session using a timestamp / 使用当前时间戳生成对话专属文件夹名称
    timestamp = datetime.datetime.now().strftime("%Y.%m.%d_%H:%M:%S")
    session_title = f"chat_{timestamp}"
    main_folder = os.path.join("output", session_title)

    # Create the main output folder / 创建主文件夹
    os.makedirs(main_folder, exist_ok=True)

    # Create a subfolder to store generated images / 创建用于存放图片的文件夹
    image_folder = os.path.join(main_folder, "images")
    os.makedirs(image_folder, exist_ok=True)

    # Path to the Markdown file storing conversation logs / 用于存储对话内容的 Markdown 文件路径
    md_file_path = os.path.join(main_folder, "index.md")

    return {
        "client": client,
        "main_folder": main_folder,
        "image_folder": image_folder,
        "md_file_path": md_file_path,
        "session_title": session_title
    }


def append_to_markdown(md_file_path, content):
    """
    Append content to the Markdown file.
    将内容追加写入 Markdown 文件
    """
    # Open in append ("a") mode to add new content at the end / 以追加（"a"）模式打开文件，将新内容写入文件末尾
    with open(md_file_path, "a", encoding="utf-8") as f:
        f.write(content)


def process_api_response(response, message_count, image_folder):
    """
    Process the API response: print text to console, save images locally, and generate Markdown-format text.
    处理 API 返回结果，将文本输出到终端，并保存图片到本地，同时生成 Markdown 格式文本
    """
    md_snippet = ""

    # Boundary check: if no candidates, return an empty string immediately / 边界检查：若无候选项，直接返回空字符串
    if not response or not response.candidates:
        return md_snippet

    # Only handle the first candidate for simplicity / 仅处理第一个候选结果
    parts = response.candidates[0].content.parts
    if not parts:
        return md_snippet

    # Used to record all image filenames generated by this request for subsequent GIF creation
    # 用于记录当前请求中产生的所有图片文件名，用来后续合成 GIF
    image_files = []

    # A separate counter for image naming, incremented only when an image is processed
    # 单独用一个计数器为图片编号，只在处理图片时递增
    image_counter = 1

    # Traverse each part of the candidate response / 遍历候选结果中的各个部分
    for part in parts:
        if part.text is not None:
            # If it's text, print to terminal and append to Markdown snippet
            # 如果是文本，输出到终端并追加到 Markdown 片段
            print("GeminiBot:", part.text)
            md_snippet += part.text + "\n\n"
        elif part.inline_data is not None:
            # If it's image data, save it and generate a Markdown image link
            # 如果是图片，进行保存并生成 Markdown 图像链接
            image_filename = f"message{message_count}_image_{image_counter:03d}.png"
            image_path = os.path.join(image_folder, image_filename)
            image_rel_path = os.path.join("images", image_filename)

            try:
                # Convert binary data to an image and save / 将二进制数据转换为图片并保存
                image = Image.open(BytesIO(part.inline_data.data))
                image.save(image_path)
                print(f"Image saved to: {image_path}")

                # Keep track of the saved image for GIF creation / 记录保存的图片文件，以便后续合成 GIF
                image_files.append(image_path)

                # Insert an image link in Markdown / 在 Markdown 中插入图片链接
                md_snippet += f"![Generated Image {image_counter}]({image_rel_path})\n\n"
            except Exception as e:
                # Error handling if image saving fails / 处理图片时出现错误时的处理
                error_msg = f"Error saving image: {e}"
                print(error_msg)
                md_snippet += error_msg + "\n\n"

            # Increment image counter after processing one image / 一张图片处理完成后，让图片计数器 +1
            image_counter += 1

    # If multiple images are generated, use ffmpeg to create a GIF
    # 如果本次生成多张图片，则调用 ffmpeg 合成 GIF
    if len(image_files) > 1:
        try:
            gif_filename = f"message{message_count}_animated.gif"
            gif_path = os.path.join(image_folder, gif_filename)
            gif_rel_path = os.path.join("images", gif_filename)

            # command: ffmpeg -y -framerate 10 -i 'message%d.png' -loop 0 message.gif
            # Use ffmpeg to convert message{message_count}_image_001.png, 002.png, ... into a GIF
            # 使用 ffmpeg 将 message{message_count}_image_001.png, 002.png, ... 合成为 GIF
            subprocess.run([
                "ffmpeg",
                "-y",                  # Overwrite existing file / 覆盖已存在文件
                "-framerate", "3",     # 3 frames per second, adjustable / 每秒 3 帧，可根据需求调整
                "-i", os.path.join(image_folder, f"message{message_count}_image_%03d.png"),
                "-loop", "0",          # Infinite loop / 无限循环
                gif_path
            ], check=True)

            print(f"GIF animation created at: {gif_path}")
            md_snippet += f"![Animated GIF]({gif_rel_path})\n\n"
        except Exception as e:
            # Error handling if GIF creation fails / 合成 GIF 失败时处理
            error_msg = f"Error creating GIF: {e}"
            print(error_msg)
            md_snippet += error_msg + "\n\n"

    return md_snippet


def loading_spinner(stop_event):
    """
    A simple loading spinner in the terminal to indicate progress.
    在终端打印简单的旋转光标，实现 “loading” 效果。
    """
    spinner_chars = ['-', '\\', '|', '/']
    idx = 0
    while not stop_event.is_set():
        # Print in a loop to dynamically update terminal / 使用打印动态更新终端
        print(f"Loading {spinner_chars[idx % 4]}", end='\r')
        idx += 1
        time.sleep(0.2)
    # Clear the "Loading ..." line / 清空原来的 “Loading ...” 行
    print(' ' * 20, end='\r')


def main():
    """
    Main function: initialize the session, loop for user input, and generate responses.
    主函数：初始化会话、循环获取用户输入并生成回复
    """
    # Initialize the session / 初始化会话
    session = init_session()
    client = session["client"]
    md_file_path = session["md_file_path"]
    image_folder = session["image_folder"]

    # Write initial session info to Markdown / 将初始信息写入 Markdown，用于标记会话信息
    init_md = f"# Chat Session: {session['session_title']}\n\n"
    init_md += f"**Start Time:** {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    with open(md_file_path, "w", encoding="utf-8") as f:
        f.write(init_md)

    # Prompt user for input, end with 'exit' or 'quit' / 提示用户输入，对话以 'exit' 或 'quit' 结束
    print("Welcome to the conversation tool. Type 'exit' or 'quit' to end the conversation.")
    message_count = 1

    while True:
        try:
            # Wait for user input / 等待用户输入
            user_input = input("User: ").strip()
        except KeyboardInterrupt:
            # Gracefully handle Ctrl + C / 优雅地处理 Ctrl + C
            print("\nConversation ended by user.")
            break

        # End conversation on 'exit' or 'quit' / 如果用户输入 exit 或 quit，则结束对话
        if user_input.lower() in ["exit", "quit"]:
            print("Conversation ended.")
            break

        # Skip if the user input is empty / 跳过空输入
        if not user_input:
            continue

        # Record a timestamp for each user message / 为每条用户消息记录时间戳
        message_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Append user input in Markdown format to the file / 将用户输入以 Markdown 格式追加到文件中
        user_md = f"**User [{message_timestamp}]:** {user_input}\n\n"
        append_to_markdown(md_file_path, user_md)

        # Create event object and thread for the loading spinner / 创建事件对象与线程，用于显示加载动画
        stop_event = threading.Event()
        spinner_thread = threading.Thread(target=loading_spinner, args=(stop_event,))
        spinner_thread.start()

        # Call the API to generate a response / 调用 API 生成回复
        try:
            response = client.models.generate_content(
                model="models/gemini-2.0-flash-exp",
                contents=user_input,
                config=types.GenerateContentConfig(response_modalities=['Text', 'Image'])
            )
        except Exception as e:
            # If API call fails, stop spinner and log error / API 调用失败则停止加载动画并记录错误
            stop_event.set()
            spinner_thread.join()

            error_msg = f"Error calling API: {e}"
            print(error_msg)
            append_to_markdown(md_file_path, error_msg + "\n\n")
            continue
        finally:
            # Stop the spinner after the request finishes, error or not / 无论是否出错，请求完成后都停止加载动画
            stop_event.set()
            spinner_thread.join()

        # Process the response and get Markdown content / 处理回复，并得到 Markdown 格式内容
        bot_md_header = f"**GeminiBot [{message_timestamp}]:**\n\n"
        bot_md_body = process_api_response(response, message_count, image_folder)

        # Append AI response to the Markdown file / 将生成式 AI 的回复追加写入 Markdown 文件
        append_to_markdown(md_file_path, bot_md_header + bot_md_body)

        # Increment message count / 消息计数 +1
        message_count += 1

    # When conversation ends, print the folder path where logs are saved / 会话结束，打印保存对话的文件夹路径
    print(f"\nAll conversation content has been saved in: {session['main_folder']}")


if __name__ == "__main__":
    main()
